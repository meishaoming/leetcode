[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

### 解法一：哈希映射

1. 把一个数组中的值和它出现的次出记录到哈希映射里
2. 逐一取另一个数组中的值，到哈希表里去找，找到了就 append 进结果，并且相应哈希映射值减 1

```py
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        visited = {}
        for x in nums1:
            if x in visited:
                visited[x] += 1
            else:
                visited[x] = 1

        ans = []
        for x in nums2:
            if x in visited and visited[x] > 0:
                ans.append(x)
                visited[x] -= 1
        return ans
```

优化一下，使用 collections.Counter

```py
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        from collections import Counter
        visited = Counter(nums1)
        ans = []
        for x in nums2:
            if x in visited and visited[x] > 0:
                ans.append(x)
                visited[x] -= 1
        return ans
```


### 解法二：排序+二分法

1. 对两个数组排序
2. 从其中一个数组 A 中取值，到另一个数组 B 中用二分法找位置。并且记录当前找到的左边位置 pos
3. 下次再找的时候，从 pos+1 开始找

```py
import bisect

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        start = 0
        ans = []
        for x in nums1:
            pos = bisect.bisect_left(nums2, x, start)
            if pos == len(nums2):
                break
            elif x == nums2[pos]:
                ans.append(x)
                start = pos+1
        return ans
```

bisect 是 python 中二分法查找的库。bisect.bisect_left(nums, x) 返回 x 在 nums 中适合插入的最左边位置。

比如 `nums = [ 1, 3, 3, 3, 5 ]`

`bisect.bisect_left(nums, 3)` 就返回 1，插入成为最左边的 3

`bisect.bisect_right(nums, 3)` 就返回 4，插入成为最右边的 3
